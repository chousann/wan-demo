{"ast":null,"code":"import _asyncToGenerator from \"E:/workspaces/wan-demo/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./auth.service\";\nexport class WebauthnService {\n  constructor(authService) {\n    this.authService = authService;\n  }\n\n  register(username) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Get registration options from server\n      const options = yield _this.authService.getRegistrationOptions(username).toPromise(); // Convert challenge and user ID to ArrayBuffer\n\n      options.challenge = _this.base64ToArrayBuffer(options.challenge);\n      options.user.id = _this.base64ToArrayBuffer(options.user.id); // Process pubKeyCredParams if needed\n\n      if (options.pubKeyCredParams) {\n        options.pubKeyCredParams = options.pubKeyCredParams.map(param => {\n          return { ...param\n          };\n        });\n      }\n\n      try {\n        // Create credential using WebAuthn API\n        const credential = yield navigator.credentials.create({\n          publicKey: options\n        }); // Convert credential response to serializable format\n\n        const serializedCredential = {\n          id: credential.id,\n          rawId: _this.arrayBufferToBase64(credential.rawId),\n          response: {\n            attestationObject: _this.arrayBufferToBase64(credential.response.attestationObject),\n            clientDataJSON: _this.arrayBufferToBase64(credential.response.clientDataJSON),\n            publicKey: credential.response.getPublicKey ? _this.arrayBufferToBase64(credential.response.getPublicKey()) : null,\n            publicKeyAlgorithm: credential.response.getPublicKeyAlgorithm ? credential.response.getPublicKeyAlgorithm() : null,\n            counter: 0\n          },\n          type: credential.type\n        };\n        return serializedCredential;\n      } catch (error) {\n        console.error('Registration failed:', error);\n        throw error;\n      }\n    })();\n  }\n\n  login(username) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Get login options from server\n      const options = yield _this2.authService.getLoginOptions(username).toPromise(); // Convert challenge to ArrayBuffer\n\n      options.challenge = _this2.base64ToArrayBuffer(options.challenge); // Convert allowCredentials IDs to ArrayBuffer\n\n      if (options.allowCredentials) {\n        options.allowCredentials = options.allowCredentials.map(cred => {\n          return { ...cred,\n            id: _this2.base64ToArrayBuffer(cred.id)\n          };\n        });\n      }\n\n      try {\n        // Get credential using WebAuthn API\n        const credential = yield navigator.credentials.get({\n          publicKey: options\n        }); // Convert credential response to serializable format\n\n        const serializedCredential = {\n          id: credential.id,\n          rawId: _this2.arrayBufferToBase64(credential.rawId),\n          response: {\n            authenticatorData: _this2.arrayBufferToBase64(credential.response.authenticatorData),\n            clientDataJSON: _this2.arrayBufferToBase64(credential.response.clientDataJSON),\n            signature: _this2.arrayBufferToBase64(credential.response.signature),\n            userHandle: credential.response.userHandle ? _this2.arrayBufferToBase64(credential.response.userHandle) : null\n          },\n          type: credential.type\n        };\n        return serializedCredential;\n      } catch (error) {\n        console.error('Authentication failed:', error);\n        throw error;\n      }\n    })();\n  }\n\n  base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    return bytes.buffer;\n  }\n\n  arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n\n    return btoa(binary);\n  }\n\n  static {\n    this.ɵfac = function WebauthnService_Factory(t) {\n      return new (t || WebauthnService)(i0.ɵɵinject(i1.AuthService));\n    };\n\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: WebauthnService,\n      factory: WebauthnService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["WebauthnService","constructor","authService","register","username","options","getRegistrationOptions","toPromise","challenge","base64ToArrayBuffer","user","id","pubKeyCredParams","map","param","credential","navigator","credentials","create","publicKey","serializedCredential","rawId","arrayBufferToBase64","response","attestationObject","clientDataJSON","getPublicKey","publicKeyAlgorithm","getPublicKeyAlgorithm","counter","type","error","console","login","getLoginOptions","allowCredentials","cred","get","authenticatorData","signature","userHandle","base64","binaryString","atob","bytes","Uint8Array","length","i","charCodeAt","buffer","binary","byteLength","String","fromCharCode","btoa","i0","factory","providedIn"],"sourceRoot":"","sources":["E:\\workspaces\\wan-demo\\frontend\\src\\app\\webauthn.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class WebauthnService {\n\n  constructor(private authService: AuthService) { }\n\n  async register(username: string): Promise<any> {\n    // Get registration options from server\n    const options = await this.authService.getRegistrationOptions(username).toPromise();\n    \n    // Convert challenge and user ID to ArrayBuffer\n    options.challenge = this.base64ToArrayBuffer(options.challenge);\n    options.user.id = this.base64ToArrayBuffer(options.user.id);\n    \n    // Process pubKeyCredParams if needed\n    if (options.pubKeyCredParams) {\n      options.pubKeyCredParams = options.pubKeyCredParams.map((param: any) => {\n        return {\n          ...param\n        };\n      });\n    }\n    \n    try {\n      // Create credential using WebAuthn API\n      const credential = await navigator.credentials.create({ publicKey: options }) as any;\n      \n      // Convert credential response to serializable format\n      const serializedCredential = {\n        id: credential.id,\n        rawId: this.arrayBufferToBase64(credential.rawId),\n        response: {\n          attestationObject: this.arrayBufferToBase64(credential.response.attestationObject),\n          clientDataJSON: this.arrayBufferToBase64(credential.response.clientDataJSON),\n          publicKey: credential.response.getPublicKey ? \n            this.arrayBufferToBase64(credential.response.getPublicKey()) : null,\n          publicKeyAlgorithm: credential.response.getPublicKeyAlgorithm ? \n            credential.response.getPublicKeyAlgorithm() : null,\n          counter: 0\n        },\n        type: credential.type\n      };\n      \n      return serializedCredential;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      throw error;\n    }\n  }\n\n  async login(username: string): Promise<any> {\n    // Get login options from server\n    const options = await this.authService.getLoginOptions(username).toPromise();\n    \n    // Convert challenge to ArrayBuffer\n    options.challenge = this.base64ToArrayBuffer(options.challenge);\n    \n    // Convert allowCredentials IDs to ArrayBuffer\n    if (options.allowCredentials) {\n      options.allowCredentials = options.allowCredentials.map((cred: any) => {\n        return {\n          ...cred,\n          id: this.base64ToArrayBuffer(cred.id)\n        };\n      });\n    }\n    \n    try {\n      // Get credential using WebAuthn API\n      const credential = await navigator.credentials.get({ publicKey: options }) as any;\n      \n      // Convert credential response to serializable format\n      const serializedCredential = {\n        id: credential.id,\n        rawId: this.arrayBufferToBase64(credential.rawId),\n        response: {\n          authenticatorData: this.arrayBufferToBase64(credential.response.authenticatorData),\n          clientDataJSON: this.arrayBufferToBase64(credential.response.clientDataJSON),\n          signature: this.arrayBufferToBase64(credential.response.signature),\n          userHandle: credential.response.userHandle ? \n            this.arrayBufferToBase64(credential.response.userHandle) : null\n        },\n        type: credential.type\n      };\n      \n      return serializedCredential;\n    } catch (error) {\n      console.error('Authentication failed:', error);\n      throw error;\n    }\n  }\n\n  private base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  private arrayBufferToBase64(buffer: ArrayBuffer): string {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n}"]},"metadata":{},"sourceType":"module"}