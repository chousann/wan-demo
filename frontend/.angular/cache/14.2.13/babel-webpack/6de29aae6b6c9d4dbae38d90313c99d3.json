{"ast":null,"code":"import _asyncToGenerator from \"E:/workspaces/wan-demo/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./auth.service\";\nexport class WebauthnService {\n  constructor(authService) {\n    this.authService = authService;\n  }\n\n  register(username) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Get registration options from server\n      const options = yield _this.authService.getRegistrationOptions(username).toPromise(); // Convert challenge and user ID to ArrayBuffer\n\n      options.challenge = _this.base64UrlToArrayBuffer(options.challenge);\n      options.user.id = _this.base64UrlToArrayBuffer(options.user.id); // Process pubKeyCredParams if needed\n\n      if (options.pubKeyCredParams) {\n        options.pubKeyCredParams = options.pubKeyCredParams.map(param => {\n          return { ...param\n          };\n        });\n      }\n\n      try {\n        // Create credential using WebAuthn API\n        const credential = yield navigator.credentials.create({\n          publicKey: options\n        }); // Convert credential response to serializable format\n\n        const serializedCredential = {\n          id: credential.id,\n          rawId: _this.arrayBufferToBase64Url(credential.rawId),\n          response: {\n            attestationObject: _this.arrayBufferToBase64Url(credential.response.attestationObject),\n            clientDataJSON: _this.arrayBufferToBase64Url(credential.response.clientDataJSON),\n            publicKey: credential.response.getPublicKey ? _this.arrayBufferToBase64Url(credential.response.getPublicKey()) : null,\n            publicKeyAlgorithm: credential.response.getPublicKeyAlgorithm ? credential.response.getPublicKeyAlgorithm() : null,\n            counter: 0\n          },\n          type: credential.type\n        };\n        return serializedCredential;\n      } catch (error) {\n        console.error('Registration failed:', error);\n        throw error;\n      }\n    })();\n  }\n\n  login(username) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Get login options from server\n      const options = yield _this2.authService.getLoginOptions(username).toPromise(); // Convert challenge to ArrayBuffer\n\n      options.challenge = _this2.base64UrlToArrayBuffer(options.challenge); // Convert allowCredentials IDs to ArrayBuffer\n\n      if (options.allowCredentials) {\n        options.allowCredentials = options.allowCredentials.map(cred => {\n          return { ...cred,\n            id: _this2.base64UrlToArrayBuffer(cred.id)\n          };\n        });\n      }\n\n      try {\n        // Get credential using WebAuthn API\n        const credential = yield navigator.credentials.get({\n          publicKey: options\n        }); // Convert credential response to serializable format\n\n        const serializedCredential = {\n          id: credential.id,\n          rawId: _this2.arrayBufferToBase64Url(credential.rawId),\n          response: {\n            authenticatorData: _this2.arrayBufferToBase64Url(credential.response.authenticatorData),\n            clientDataJSON: _this2.arrayBufferToBase64Url(credential.response.clientDataJSON),\n            signature: _this2.arrayBufferToBase64Url(credential.response.signature),\n            userHandle: credential.response.userHandle ? _this2.arrayBufferToBase64Url(credential.response.userHandle) : null\n          },\n          type: credential.type\n        };\n        return serializedCredential;\n      } catch (error) {\n        console.error('Authentication failed:', error);\n        throw error;\n      }\n    })();\n  }\n\n  base64UrlToArrayBuffer(base64Url) {\n    // Convert base64url to base64\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/').replace(/=/g, ''); // Add padding if needed\n\n    const padLength = (4 - base64.length % 4) % 4;\n    const paddedBase64 = base64 + '='.repeat(padLength);\n\n    try {\n      const binaryString = atob(paddedBase64);\n      const bytes = new Uint8Array(binaryString.length);\n\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n\n      return bytes.buffer;\n    } catch (e) {\n      console.error('Failed to decode base64 string:', base64Url);\n      throw e;\n    }\n  }\n\n  arrayBufferToBase64Url(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n\n    const base64 = btoa(binary); // Convert base64 to base64url\n\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  }\n\n  static {\n    this.ɵfac = function WebauthnService_Factory(t) {\n      return new (t || WebauthnService)(i0.ɵɵinject(i1.AuthService));\n    };\n\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: WebauthnService,\n      factory: WebauthnService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["WebauthnService","constructor","authService","register","username","options","getRegistrationOptions","toPromise","challenge","base64UrlToArrayBuffer","user","id","pubKeyCredParams","map","param","credential","navigator","credentials","create","publicKey","serializedCredential","rawId","arrayBufferToBase64Url","response","attestationObject","clientDataJSON","getPublicKey","publicKeyAlgorithm","getPublicKeyAlgorithm","counter","type","error","console","login","getLoginOptions","allowCredentials","cred","get","authenticatorData","signature","userHandle","base64Url","base64","replace","padLength","length","paddedBase64","repeat","binaryString","atob","bytes","Uint8Array","i","charCodeAt","buffer","e","binary","byteLength","String","fromCharCode","btoa","i0","factory","providedIn"],"sourceRoot":"","sources":["E:\\workspaces\\wan-demo\\frontend\\src\\app\\webauthn.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class WebauthnService {\n\n  constructor(private authService: AuthService) { }\n\n  async register(username: string): Promise<any> {\n    // Get registration options from server\n    const options: any = await this.authService.getRegistrationOptions(username).toPromise();\n    \n    // Convert challenge and user ID to ArrayBuffer\n    options.challenge = this.base64UrlToArrayBuffer(options.challenge);\n    options.user.id = this.base64UrlToArrayBuffer(options.user.id);\n    \n    // Process pubKeyCredParams if needed\n    if (options.pubKeyCredParams) {\n      options.pubKeyCredParams = options.pubKeyCredParams.map((param: any) => {\n        return {\n          ...param\n        };\n      });\n    }\n    \n    try {\n      // Create credential using WebAuthn API\n      const credential = await navigator.credentials.create({ publicKey: options }) as any;\n      \n      // Convert credential response to serializable format\n      const serializedCredential = {\n        id: credential.id,\n        rawId: this.arrayBufferToBase64Url(credential.rawId),\n        response: {\n          attestationObject: this.arrayBufferToBase64Url(credential.response.attestationObject),\n          clientDataJSON: this.arrayBufferToBase64Url(credential.response.clientDataJSON),\n          publicKey: credential.response.getPublicKey ? \n            this.arrayBufferToBase64Url(credential.response.getPublicKey()) : null,\n          publicKeyAlgorithm: credential.response.getPublicKeyAlgorithm ? \n            credential.response.getPublicKeyAlgorithm() : null,\n          counter: 0\n        },\n        type: credential.type\n      };\n      \n      return serializedCredential;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      throw error;\n    }\n  }\n\n  async login(username: string): Promise<any> {\n    // Get login options from server\n    const options: any = await this.authService.getLoginOptions(username).toPromise();\n    \n    // Convert challenge to ArrayBuffer\n    options.challenge = this.base64UrlToArrayBuffer(options.challenge);\n    \n    // Convert allowCredentials IDs to ArrayBuffer\n    if (options.allowCredentials) {\n      options.allowCredentials = options.allowCredentials.map((cred: any) => {\n        return {\n          ...cred,\n          id: this.base64UrlToArrayBuffer(cred.id)\n        };\n      });\n    }\n    \n    try {\n      // Get credential using WebAuthn API\n      const credential = await navigator.credentials.get({ publicKey: options }) as any;\n      \n      // Convert credential response to serializable format\n      const serializedCredential = {\n        id: credential.id,\n        rawId: this.arrayBufferToBase64Url(credential.rawId),\n        response: {\n          authenticatorData: this.arrayBufferToBase64Url(credential.response.authenticatorData),\n          clientDataJSON: this.arrayBufferToBase64Url(credential.response.clientDataJSON),\n          signature: this.arrayBufferToBase64Url(credential.response.signature),\n          userHandle: credential.response.userHandle ? \n            this.arrayBufferToBase64Url(credential.response.userHandle) : null\n        },\n        type: credential.type\n      };\n      \n      return serializedCredential;\n    } catch (error) {\n      console.error('Authentication failed:', error);\n      throw error;\n    }\n  }\n\n  private base64UrlToArrayBuffer(base64Url: string): ArrayBuffer {\n    // Convert base64url to base64\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/').replace(/=/g, '');\n    \n    // Add padding if needed\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const paddedBase64 = base64 + '='.repeat(padLength);\n    \n    try {\n      const binaryString = atob(paddedBase64);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      return bytes.buffer;\n    } catch (e) {\n      console.error('Failed to decode base64 string:', base64Url);\n      throw e;\n    }\n  }\n\n  private arrayBufferToBase64Url(buffer: ArrayBuffer): string {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    const base64 = btoa(binary);\n    // Convert base64 to base64url\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  }\n}"]},"metadata":{},"sourceType":"module"}